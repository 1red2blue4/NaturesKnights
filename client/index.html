<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="media/logo.png" />
  <style>
    @font-face{
      font-family: nature;
      src: url(media/dream_orphans/dreamorphans.ttf);
    }
    @font-face{
      font-family: sourceSans;
      src: url(media/source_sans/SourceSansPro-Regular.ttf);
    }
    @font-face{
      font-family: roboto;
      src: url(media/Roboto/Roboto-Black.ttf);
    }
    canvas{
      background-color: rgb(90, 250, 90);
      font-family: nature;
      position: absolute;
      margin: 0px 0 0 -375px;
      left: 50%;
    }
    html{
      overflow-y: hidden;
    }
    body{
      background-color: rgb(50, 50, 50);
    }
    h1{
      text-align: center;
      color: rgb(205, 160, 10);
      font-family: nature;
      font-size: 30pt;
    }
    #credits{
      position: absolute;
      bottom: 0px;
      width: 130px;
      height: 100%;
      background-color: rgb(0, 0, 0);
      margin-left: 0px;
    }
    h2{
      color: rgb(255, 255, 255);
    }
    h3{
      color: rgb(255, 255, 255);
    }
    #game_design{
      position: absolute;
      top: 30px;
      left: 10px;
      font-family: sourceSans;
    }
    #sound_design{
      position: absolute;
      top: 230px;
      left: 10px;
      font-family: sourceSans;
    }
    #asset_production{
      position: absolute;
      top: 430px;
      left: 10px;
      font-family: sourceSans;
    }
    #musicToggle{
      position: absolute;
      bottom: -65px;
      background-color: rgb(20, 20, 20);
      right: 100px;
      border-radius: 25px;
      line-height: 3px;
      transition: 1s;
    }
    #musicToggle:hover{
      bottom: -30px;
      transition: 1s;
      cursor: pointer;
    }
    h4{
      color: rgb(120, 120, 120);
      font-family: sourceSans;
      text-align: center;
    }
    h5{
      color: rgb(120, 120, 120);
      font-family: sourceSans;
      text-align: center;
    }
    h6{
      background-color: rgb(20, 20, 20);
    }
  </style>
  <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script type="text/babel">
  
    "use strict";

    var myKeys = {};

    // myKeys.keydown array to keep track of which keys are down
    // this is called a "key daemon"
    // main.js will "poll" this array every frame
    // this works because JS has "sparse arrays" - not every language does
    myKeys.keydown = [];
    myKeys.keyup = [];

    let socket;

    let canvas = document.querySelector("canvas");
    let ctx = canvas.getContext("2d");
    let WIDTH;
    let HEIGHT;
    let buffer = document.createElement("canvas");
    let btx = buffer.getContext("2d");
    let yourTicketNum;
    let yourRoomNum;
    let yourCharacters = {};
    let bothPlayersAvailable = false;
    let takingTurn = false;
    let turnTaken = false;
    let enemyLeft = false;
    let stopBlinking = false;
    
    let currKnightArrowPos = -1;
    let currKnight = {};
    currKnight.teamNum = -1;

    let toggleMusicButton = document.querySelector("#musicToggle");

    //set button values
    let buttonWidth = 125;
    let buttonHeight = 75;
    let buttonPosY = 375;
    let buttonPosX1 = 20;

    let descriptionBoxPosX = 475;
    let descriptionBoxPosY = 350;
    let descriptionBoxWidth = 300;
    let descriptionBoxHeight = 200;
    let descriptionBoxFill = "rgb(255, 255, 225)";

    let team1StartPos = 305;
    let team2StartPos = 385;

    let buttonColor = "rgb(240, 230, 80)";
    let highlightButtonColor = "rgb(230, 210, 40)";
    let currentButton = 0;
    let bloatSize = 10;
    let bloatSizeCap = 10;
    let lineBloat = 4;
    let maxLineBloat = 4;

    //set outter box values
    let outterBoxPosX = buttonPosX1 - bloatSize*3/2 - 3;
    let outterBoxPosY = buttonPosY - bloatSize - 3;
    let outterBoxWidth = buttonWidth + bloatSize*3 + 6;
    let outterBoxHeight = buttonHeight + bloatSize*2 + 6;

    //space between one team member position and the next
    let teamMemberIncrement = 75;

    let targetKnight = 0;
    let targettedKnight = 0;
    let sendDamageInfo = {type: "hurt", number: 1}; 
    let receiveDamageInfo = {type: "hurt", number: 1};
    let showDealDamage = false;
    let showTakeDamage = false;
    let frame = 0;
    let freezeFrameSend = 0;
    let freezeFrameReceive = 0;
    let alphValSend = 0;
    let alphValReceive = 0;
    let sendHittingAll = false;
    let receiveHittingAll = false;

    let showTargetBox = false;
    let targetBoxNum = 0;

    let showAssistBox = false;
    let showHealSend = false;
    let showHealReceive = false;

    let attackFailed = false;
    //let showReceiveAssistBox = false;

    //let ghostImg = new Image();
    let backgroundImage = new Image();
    let arrowImage = new Image();
    let arrowSpritesheetImage = new Image();
    let leftArrowImage = new Image();
    let rightArrowImage = new Image();
    let healthCircleImage = new Image();
    let knightImages = {
      monkey: new Image(),
      blossomBird: new Image(),
      sponge: new Image(),
      stupidSnake: new Image(),
      seaSerpent: new Image(),
      redRect: new Image(),
      savageTiger: new Image(),
      stupidSnake: new Image(),
      chipmonk: new Image(),
    };
    let backgroundMusic = new Audio();
    /*
    let soundEffects = {
      
    };
    let monkeyImage = new Image();
    let blossomBirdImage = new Image();
    let spongeImage = new Image();
    let stupidSnakeImage = new Image();
    let seaSerpentImage = new Image();
    let redRectImage = new Image();
    */

    let draws = {};

    let CreateSpecialFeatures = (kncksOvr, psns, brns, brksShld, htsFlng, drct, trgts) => {
      let mySpecialFeatures = {};
      mySpecialFeatures.knocksOver = kncksOvr;
      mySpecialFeatures.burns = brns;
      mySpecialFeatures.poisons = psns;
      mySpecialFeatures.breaksShield = brksShld;
      mySpecialFeatures.targets = trgts;
      mySpecialFeatures.hitsFlying = htsFlng;
      mySpecialFeatures.direct = drct;
      return mySpecialFeatures;
    };

    let CreateAttack = (nm, dmg, mna, dscrptn, spclFtrs) => {
      let myAttack = {};
      myAttack.name = nm;
      myAttack.ATK = dmg;
      myAttack.mana = mna;
      myAttack.description = dscrptn;
      myAttack.specialFeatures = spclFtrs;
      return myAttack;
    };

    let CreateKnight = (nm, hlth, def, spd, drftPts, cnKnckOvr, flng, spkd, atcks, img, strngNm) => {
      let myKnight = {};
      myKnight.name = nm;
      myKnight.stringName = strngNm;
      myKnight.HLTH = hlth;
      myKnight.maxHealth = hlth;
      myKnight.DEF = def;
      myKnight.speed = spd;
      myKnight.draftPoints = drftPts;
      myKnight.canKnockOver = cnKnckOvr;
      myKnight.knockedOver = false;
      myKnight.alive = true;
      myKnight.poisoned = false;
      myKnight.burned = false;
      myKnight.flying = flng;
      myKnight.spiked = spkd;
      myKnight.attacks = atcks;
      myKnight.image = img;
      myKnight.shaking = false;
      //myKnight.image[myKnight.name]
      return myKnight;
    };

    //setInputDaemon function taken directly from IGME-330
    const setInputDaemon = () => {
      myKeys.KEYBOARD = Object.freeze({
        "KEY_ENTER": 13,
        "KEY_LEFT": 37, 
        "KEY_UP": 38, 
        "KEY_RIGHT": 39, 
        "KEY_DOWN": 40,
        "KEY_SPACE": 32,
        "KEY_SHIFT": 16,
        "KEY_W": 87,
        "KEY_A": 65,
        "KEY_S": 83,
        "KEY_D": 68,
        "KEY_T": 84
      });
      
      // event listeners
      window.addEventListener("keydown",function(e){
        myKeys.keydown[e.keyCode] = true;
      });

      window.addEventListener("keyup",function(e){
        myKeys.keydown[e.keyCode] = false;
        
        myKeys.keyup[e.keyCode] = true;

        // pausing and resuming
        var char = String.fromCharCode(e.keyCode);
        if (char == "p" || char == "P"){
          if (app.main.paused){
            app.main.resumeGame();
          } else {
            app.main.pauseGame();
          }
        }

        if (char == "d" || char == "D")
        {
          app.main.toggleDebug();
        }
      });
    };

    let savageTiger = CreateKnight("Savage Tiger", 5, 0, 13, 2, false, false, false,
      [CreateAttack("Claw", 2, 0, "Claw the enemy apart.", 
        CreateSpecialFeatures(false, false, false, true, false, true, "front")
      )],
      knightImages.savageTiger,
      "savageTiger"
    );

    let chipmonk = CreateKnight("Chipmonk", 2, 0, 7, 1, false, false, false,
      [CreateAttack("Bonk", 1, 0, "Bonks the enemy with your head.",
        CreateSpecialFeatures(true, false, false, false, true, true, "any")
      )],
      knightImages.chipmonk,
      "chipmonk"
    );

    let seaSerpent = CreateKnight("Sea Serpent", 7, 0, 8, 3, false, true, false,
      [CreateAttack("Wave Smash", 2, 0, "Smashes the enemy with a tidal wave.",
        CreateSpecialFeatures(true, false, false, false, false, false, "front")
      ), CreateAttack("Sea Gust", 1, 1, "Sends a gust of wind at the enemies",
        CreateSpecialFeatures(false, false, false, true, false, false, "all")
      )],
      knightImages.seaSerpent,
      "seaSerpent"
    );

    let blossomBird = CreateKnight("Blossom Bird", 7, 0, 12, 3, false, true, false,
      [CreateAttack("Dive", 3, 0, "Dive straight through an enemy.",
        CreateSpecialFeatures(false, false, false, false, true, true, "any")
      ),
      CreateAttack("Blossom", 3, 2, "Heal a character 3 health.", 
        CreateSpecialFeatures(false, false, false, false, false, false, "healAny")
      )],
      knightImages.blossomBird,
      "blossomBird"
    );

    let sponge = CreateKnight("Sponge", 10, 1, 4, 3, false, false, false,
      [CreateAttack("Lunge", 1, 0, "Jump at the enemy.", 
        CreateSpecialFeatures(false, false, false, false, false, true, "any")
      )],
      knightImages.sponge,
      "sponge"
    );

    /*
    let sillyDog = {};

    let schemingMonkey = {};

    let smallCrab = {};

    let slashingCrab = {};

    let lightningSnake = {};

    let thunderSnake = {};

    let giantSnake = {};

    let stupidSnake = {};

    let thoughtDweller = {};

    let slashingFrog = {};

    let spaceMouse = {};

    let thoughtfulCricket = {};

    let savageSoulBear = {};

    let monkey = {};

    let punchingRunt = {};

    let spaceDweller = {};

    let witchBear = {};
    */

    let allKnights = [chipmonk, savageTiger, seaSerpent, blossomBird, sponge];
    //let takenMembers = {};

    let yourTeam = [savageTiger, chipmonk, savageTiger, seaSerpent, blossomBird];
    let enemyTeam = {};
    let turnOrder = {};

    //calculateTeam() sets yourTeam, inputs number of members
    //for now, always 5
    const calculateTeam = (numMembers) => {
      for (let i = 0; i < numMembers; i++)
      {
        yourTeam[i] = calculateTeamMember(i);
      }
    };

    //calculateTeamMember() takes in number of previous members calculated and outputs a knight
    const calculateTeamMember = (numPrevMembers) => {
      
      let takenMembers = [];
      let count = 0;
      
      //set what members you have already taken
      for (let i = 0; i < numPrevMembers; i++)
      {
        //takenMembers = [];
        takenMembers[i] = yourTeam[i];
      }
      
      //get a random element from the array of all knights
      let knightSet = allKnights[Math.floor(Math.random()*allKnights.length)];
      
      //as long
      while (takenMembers.includes(knightSet))
      {
        knightSet = allKnights[Math.floor(Math.random()*allKnights.length)];
      }
      
      return knightSet;
    };

    const draw = (myTeam, theirTeam) => {

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.drawImage(backgroundImage, 0, 0);
      
      //you are red team
      if (yourTicketNum % 2 == 1) {
        drawUI(myTeam, theirTeam, team1StartPos, team2StartPos, buttonPosX1, "red", "blue", 1);
      }
      else
      {
        drawUI(myTeam, theirTeam, team1StartPos, team2StartPos, buttonPosX1, "blue", "red", 2);
      }
      
      frame++;
      
      console.dir(myTeam);
      console.dir(yourTeam);
      
      //console.log(`Target Knight: ${targetKnight}`);
      //console.log(`Targetted Knight: ${targettedKnight}`)
    };

    const checkPlayerInput = () => {
      //if the player hits enter, take their turn
      if (takingTurn && myKeys.keyup[myKeys.KEYBOARD.KEY_ENTER])
      {
        const getAttackType = lookForAttType(currKnight.attacks[currentButton]);
        receiveHittingAll = false;
        if (getAttackType === "attackAll")
        {
          sendHittingAll = true;
          
          for (let i = 0; i < enemyTeam.length; i++)
          {
            targetKnight = i + 5;
            useAttack(currKnight.attacks[currentButton], getAttackType);
          }
          currentButton = 0;
        }
        else if (!showTargetBox && !showAssistBox)
        {
          //showTargetBox = false;
          
          //targetKnight = targetBoxNum + 5;
          useAttack(currKnight.attacks[currentButton], getAttackType);
        }
        
        myKeys.keyup[myKeys.KEYBOARD.KEY_ENTER] = false;
      }
      //if you press shift, select enemy
      if (takingTurn && myKeys.keyup[myKeys.KEYBOARD.KEY_SHIFT])
      {
        const getAttackType = "selectTarget";
        if (showAssistBox)
        {
          showAssistBox = false;
          targetKnight = targetBoxNum;
          useAssistAbility(currKnight.attacks[currentButton], getAttackType);
        }
        else if (showTargetBox)
        {
          showTargetBox = false;
          targetKnight = targetBoxNum + 5;
          useAttack(currKnight.attacks[currentButton], getAttackType);
        }
        
        myKeys.keyup[myKeys.KEYBOARD.KEY_SHIFT] = false;
      }
      //move to the next button option
      if (takingTurn && myKeys.keyup[myKeys.KEYBOARD.KEY_RIGHT])
      {
        //selecting an attack
        if (!showTargetBox && !showAssistBox)
        {
          //reset bloat
          bloatSize = 0;
          lineBloat = 0;
          const numOptions = turnOrder[0].attacks.length;
          currentButton++;
          if (currentButton > numOptions - 1)
          {
            currentButton = 0;
          }
        }
        //selecting an enemy
        else if (showTargetBox)
        {
          const targetOptions = enemyTeam.length;
          targetBoxNum = queryDirectionKey(enemyTeam, true, true, targetBoxNum);
        }
        //selecting an ally
        else
        {
          const targetOptions = yourTeam.length;
          targetBoxNum = queryDirectionKey(yourTeam, false, false, targetBoxNum);
        }
        myKeys.keyup[myKeys.KEYBOARD.KEY_RIGHT] = false;
      }
      //move to the previous button option
      if (takingTurn && myKeys.keyup[myKeys.KEYBOARD.KEY_LEFT])
      {
        if (!showTargetBox && !showAssistBox)
        {
          //reset bloat
          bloatSize = 0;
          lineBloat = 0;
          const numOptions = turnOrder[0].attacks.length;
          currentButton--;
          if (currentButton < 0)
          {
            currentButton = numOptions - 1;
          }
        }
        else if (showTargetBox)
        {
          const targetOptions = enemyTeam.length;
          targetBoxNum = queryDirectionKey(enemyTeam, false, false, targetBoxNum);
        }
        else
        {
          const targetOptions = yourTeam.length;
          targetBoxNum = queryDirectionKey(yourTeam, true, true, targetBoxNum);
        }
        
        myKeys.keyup[myKeys.KEYBOARD.KEY_LEFT] = false;
      }
    };
    
    //queryDirectionKey() used in checkPlayerInput()
    //passes in the team, whether or not you are incrementing, and whether or not you are checking to see if it is greater than the bounds, and the current box number
    //will call itself if the character passed over is dead
    //returns the box number
    const queryDirectionKey = (team, increment, greater, theBoxNum) => {
      const targetOptions = team.length;
      let boxNum = theBoxNum;
      //based upon the increment
      if (increment)
      {
        boxNum++;
      }
      else
      {
        boxNum--;  
      }
      //wrap
      if (greater && boxNum > targetOptions - 1)
      {
        boxNum = 0;
      }
      else if (!greater && boxNum < 0)
      {
        boxNum = targetOptions - 1;
      }
      //if you reach a dead character, do this again
      if (!team[boxNum].alive)
      {
        boxNum = queryDirectionKey(team, increment, greater, boxNum);
      }
      return boxNum;
    };

    //create useAttack() function
    const useAttack = (myAttack, targetType) => {
      
      useAttackCalc(myAttack, targetType);
      useAttackUI(myAttack, targetType);
      useAttackCleanup(targetType);
      
    };

    const useAttackUI = (myAttack, targetType) => {
      
      showDealDamage = true;
      showTakeDamage = false;
      sendDamageInfo.type = "hurt";
      freezeFrameSend = frame;
      showTargetBox = false;
      turnTaken = true;
      takingTurn = false;
      if (sendDamageInfo.number !== 0 && sendDamageInfo.number !== "Miss!")
      {
        enemyTeam[targetKnight-5].shaking = true;
        for (let i = 0; i < yourTeam.length; i++)
        {
          yourTeam[i].shaking = false;
        }
      }
      //myKeys.keyup[myKeys.KEYBOARD.KEY_ENTER] = false;
      socket.emit("sendDamageUI", {damType: sendDamageInfo.type, damNum: sendDamageInfo.number, yourRoomNum, targetNum: targetKnight - 5, targetType });
      socket.emit("recalculateTeams", {yourTeam, enemyTeam, yourRoomNum});
    };

    const useAttackCalc = (myAttack, targetType) =>{
      
      let type = {};
      if (myAttack.specialFeatures.targets === "front")
      {
        type = "damage";
        attackArithmetic(myAttack, targetType);
      }
      else if (myAttack.specialFeatures.targets === "any")
      {
        type = "damage";
        attackArithmetic(myAttack, targetType);
      }
      else if (myAttack.specialFeatures.targets === "all")
      {
        type = "damage";
        attackArithmetic(myAttack, targetType);
      }
      else if (myAttack.specialFeatures.targets === "healAny")
      {
        sendDamageInfo.number = myAttack.ATK;
        type = "heal";
        yourTeam[targetKnight].HLTH += sendDamageInfo.number;
        if (yourTeam[targetKnight].HLTH > yourTeam[targetKnight].maxHealth)
        {
          
        }yourTeam[targetKnight].HLTH = yourTeam[targetKnight].maxHealth;
      }
    };

    const attackArithmetic = (myAttack, targetType) => {
      
      sendDamageInfo.number = myAttack.ATK;
      //calculate DEF
      if (!myAttack.specialFeatures.breaksShield)
      {
        sendDamageInfo.number -= enemyTeam[targetKnight-5].DEF;
        if (sendDamageInfo.number < 0)
        {
          sendDamageInfo.number = 0;
        }
      }
      //calculate knock over
      if (myAttack.specialFeatures.knocksOver && enemyTeam[targetKnight-5].canKnockOver)
      {
        enemyTeam[targetKnight-5].knockedOver = true;
      }
      //calculate poison
      if (myAttack.specialFeatures.poisons)
      {
        enemyTeam[targetKnight-5].poisoned = true;
      }
      //calculate burn
      if (myAttack.specialFeatures.burns)
      {
        enemyTeam[targetKnight-5].burned = true;
      }
      //calculate spiked
      if (myAttack.specialFeatures.direct && enemyTeam[targetKnight-5].spiked)
      {
        let saveCharNum = -1;
        for (let i = 0; i < yourTeam.length; i++)
        {
          if (currKnight.name == yourTeam[i].name)
          {
            saveCharNum = i;
          }
        }
        yourTeam[saveCharNum].HLTH -= 1;
      }
      //calculate flying
      if (enemyTeam[targetKnight-5].flying && !myAttack.specialFeatures.hitsFlying && targetType !== "attackAll")
      {
        sendDamageInfo.number = "Miss!";
      }
      //finally, deal damage
      if (typeof(sendDamageInfo.number) === "number")
      {
        enemyTeam[targetKnight-5].HLTH -= sendDamageInfo.number;
      }      
    }

    const useAttackCleanup = (targetType) => {
      //attack all has its own form of changing the current button to 0
      if (targetType != "attackAll")
      {
        currentButton = 0;
      }
      //set up next turn
      socket.emit("takeTurn", { turnOrder, yourRoomNum });
    };

    const useAssistAbility = (myAbility, targetType) => {
      
      showHealSend = true;
      showHealReceive = false;
      sendDamageInfo.type = "heal";
      //sendDamageInfo.number = myAbility.ATK;
      freezeFrameSend = frame;
      showAssistBox = false;
      turnTaken = true;
      takingTurn = false;
      for (let i = 0; i < yourTeam.length; i++)
      {
        yourTeam[i].shaking = false;
      }
      
      socket.emit("sendAbilityUI", {abilityType: sendDamageInfo.type, abilityNum: sendDamageInfo.number, yourRoomNum, targetNum: targetKnight, targetType });
      socket.emit("takeTurn", {turnOrder, yourRoomNum});
    };

    const lookForAttType = (myAttack) => {
      //healHurt = "hurt";
      if (myAttack.specialFeatures.targets === "front")
      {
        targetKnight = 5;
      }
      else if (myAttack.specialFeatures.targets === "any")
      {
        //targetKnight = 5;
        showTargetBox = true;
        //targetKnight = selectEnemyTarget();
      }
      else if (myAttack.specialFeatures.targets === "all")
      {
        return "attackAll";
      }
      else if (myAttack.specialFeatures.targets === "healAny")
      {
        //healHurt = "heal";
        showAssistBox = true;
      }
      else
      {
        targetKnight = 5; 
      }
      
      return "unimportant";
    };

    const selectEnemyTarget = () => {
      
    };

    const drawBubbleDamage = (healHurt, number, pos, time, freezeFrame) => {
      let timeToWait = time - freezeFrame;
      let distToEnd = time - frame;
      if (distToEnd < 0)
      {
        distToEnd = 0;
      }
      let color = "black";
      let myAlphVal = (distToEnd)/(timeToWait);
      
      if (healHurt === "hurt")
      {
        color = `rgba(255, 0, 0, ${myAlphVal})`;
      }
      else if (healHurt === "heal")
      {
        color = `rgba(0, 0, 255, ${myAlphVal} )`;
      }
      fillText(number, 40 + 75*pos, 180 + 50*alphValSend, "22pt roboto", color, "center", "middle");
      //fillText(`${distToEnd} / ${timeToWait}`, 150, 150, "20pt nature", "rgb(100, 100, 100)", "center", "middle");
      return myAlphVal;
    };

    const shakeCharacter = (healHurt, number, pos, time, freezeFrame) => {
      let timeToWait = time - freezeFrame;
      let distToEnd = time - frame;
      if (distToEnd < 0)
      {
        distToEnd = 0;
      }
      let color = "black";
      
      let myAlphVal = (distToEnd)/(timeToWait);
      let vector = {
        x: 0,
        y: 0
      }
      
      if (myAlphVal < 0.25)
      {
        vector.x = 0;
        vector.y = 0;
        return vector;
      }
      else if (myAlphVal < 0.5)
      {
        vector.x = 5;
        vector.y = 5;
        return vector;
      }
      else if (myAlphVal < 0.75)
      {
        vector.x = 5;
        vector.y = -5;
        return vector;
      }
      else
      {
        vector.x = -5;
        vector.y = -5;
        return vector;
      }
    };

    const directCurrKnight = () => {
      
      if (!takingTurn)
      {
        currKnightArrowPos = -100;
      }
      
      if (takingTurn && !stopBlinking)
      {        
        for (let i = 0; i < yourTeam.length; i++)
        {
          if (currKnight.name === yourTeam[i].name)
          {
            currKnightArrowPos = team1StartPos - teamMemberIncrement*i;
            currKnight.teamNum = i;
            break;
          }
        }
        stopBlinking = true;
      }
      
      drawArrowOnKnight(currKnightArrowPos);
    };

    const drawArrowOnKnight = (posX) => {
      ctx.drawImage(arrowSpritesheetImage, (frame % 24)*30, 0, 30, 30,  posX + 15, 200, 30, 30);
    };

    const drawUI = (myTeam, theirTeam, yourTeamStartPos, enemyTeamStartPos, buttonPosX1, yourColor, theirColor, playerNum) => {
      
      //draw red tint around your team
      drawTint(0, 0, WIDTH/2, HEIGHT, "rgba(255, 0, 0, 0.35)");
      //draw your team
      for (let i = 0; i < myTeam.length; i++)
      {
        //draw shaking
        if (myTeam[i].shaking && myTeam[i].alive === true)
        {          
          const vector = shakeCharacter(receiveDamageInfo.type, receiveDamageInfo.number, targettedKnight, freezeFrameReceive + 40, freezeFrameReceive);
          
          ctx.drawImage(knightImages[myTeam[i].stringName], 0, 0, 300, 300, yourTeamStartPos - teamMemberIncrement*i + vector.x, 250 + vector.y, 75, 75);
        }
        
        //draw normally
        else if (myTeam[i].alive === true)
        {
          console.log(`Alive: ${myTeam[i].alive}`);
          ctx.drawImage(knightImages[myTeam[i].stringName], 0, 0, 300, 300, yourTeamStartPos - teamMemberIncrement*i, 250, 75, 75);
        }
        
        //console.log(myTeam[i].alive);
        
        //show the health of the character
        if (yourTeam[i].HLTH == yourTeam[i].maxHealth)
        {
          yourTeam[i].fontColor = "rgb(5, 55, 5)";
        }
        else if (yourTeam[i].HLTH < yourTeam[i].maxHealth && yourTeam[i].HLTH > 0)
        {
          yourTeam[i].fontColor = "rgb(165, 165, 35)";
        }
        else if (yourTeam[i].HLTH == 0)
        {
          yourTeam[i].fontColor = "rgb(235, 20, 20)";
          yourTeam[i].alive = false;
        }
        
        //show health
        fillText(yourTeam[i].HLTH, yourTeamStartPos - teamMemberIncrement*i + 30, 340, "18pt roboto", yourTeam[i].fontColor, "center", "middle");
        
        //draw a background for the health
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.drawImage(healthCircleImage, 0, 0, 300, 300, yourTeamStartPos - teamMemberIncrement*i, 310, 60, 60);
        ctx.restore();
      }
      //if other player is here, draw them
      if (bothPlayersAvailable)
      {
        //draw blue tint around enemy team
        drawTint(WIDTH/2, 0, WIDTH/2, HEIGHT, "rgba(0, 0, 255, 0.15)");
        //draw enemy team
        for (let i = 0; i < theirTeam.length; i++)
        {
          if (theirTeam[i].shaking && theirTeam[i].alive)
          {
            const vector = shakeCharacter(sendDamageInfo.type, sendDamageInfo.number, targettedKnight, freezeFrameSend + 40, freezeFrameSend);
            ctx.drawImage(knightImages[theirTeam[i].stringName], 0, 0, 300, 300, enemyTeamStartPos + teamMemberIncrement*i + vector.x, 250 + vector.y, 75, 75);
          }
          else if (theirTeam[i].alive)
          {
            ctx.drawImage(knightImages[theirTeam[i].stringName], 0, 0, 300, 300, enemyTeamStartPos + teamMemberIncrement*i, 250, 75, 75);
          }
        }
      }
      //if the other player is not here, prompt the user to wait
      else if (!bothPlayersAvailable && yourTicketNum % 2 == 1)
      {
        //looking for an enemy to play against
        if (frame % 100 < 33)
        {
          fillText("Searching for an opponent..", WIDTH/2 - 133, buttonPosY, "18pt nature", "rgb(15, 15, 0)", "left", "middle");
        }
        else if (frame % 100 < 66)
        {
          fillText("Searching for an opponent...", WIDTH/2 - 133, buttonPosY, "18pt nature", "rgb(15, 15, 0)", "left", "middle");
        }
        else
        {
          fillText("Searching for an opponent....", WIDTH/2 - 133, buttonPosY, "18pt nature", "rgb(15, 15, 0)", "left", "middle");
        }
      }
      //draw your button options
      if (takingTurn)
      {
        //based upon the number of buttons, draw that button
        for (let i = 0; i < turnOrder[0].attacks.length; i++)
        {
          //highlight current button
          if (i === currentButton && !showTargetBox)
          {
            drawRectWithStroke(buttonPosX1 + 150*i - bloatSize*3/2, buttonPosY - bloatSize, buttonWidth + bloatSize*3, buttonHeight + bloatSize*2, highlightButtonColor, "rgb(70, 5, 60)", lineBloat);
            
            fillText(turnOrder[0].attacks[i].name, buttonPosX1 + buttonWidth/2 + 150*i, buttonPosY + buttonHeight/2, "14pt nature", "black", "center", "middle");
          }
          //draw all other buttons ordinarily
          else
          {
            drawRect(buttonPosX1 + 150*i, buttonPosY, buttonWidth, buttonHeight, buttonColor);
            
            fillText(turnOrder[0].attacks[i].name, buttonPosX1 + buttonWidth/2 + 150*i, buttonPosY + buttonHeight/2, "12pt nature", "black", "center", "middle");
          }
        }
        //encircle the enemy you wish to select
        if (showTargetBox)
        {
          //based on the number of enemies, create a box choice for it
          for (let i = 0; i < enemyTeam.length; i++)
          {
            if (i === targetBoxNum)
            {
              drawRectOnlyStroke(enemyTeamStartPos + teamMemberIncrement*i - 3, 247, 66, 66, "rgb(70, 5, 60)", 5);
            }
          }
        }
        //encircle the ally you wish to select
        if (showAssistBox)
        {
          //based on the number of enemies, create a box choice for it
          for (let i = 0; i < yourTeam.length; i++)
          {
            if (i === targetBoxNum)
            {
              drawRectOnlyStroke(yourTeamStartPos - teamMemberIncrement*i - 3, 247, 66, 66, "rgb(70, 5, 60)", 5);
            }
          }
        }
        //write out description
        //make a box
        drawRectWithStroke(descriptionBoxPosX, descriptionBoxPosY, descriptionBoxWidth, descriptionBoxHeight, descriptionBoxFill, "rgb(70, 5, 60)", 4);
        
        //show description  
        fillText(turnOrder[0].attacks[currentButton].description, (descriptionBoxPosX + WIDTH)/2, (descriptionBoxPosY + HEIGHT)/2, "12pt nature", "black", "center", "middle");
        
        //increase bloat size up to maximum
        if (bloatSize < bloatSizeCap)
        {
          bloatSize++;
        }
        if (lineBloat < maxLineBloat)
        {
          lineBloat++;
        }
      }
      //if it's not your turn....
      else if (!takingTurn && bothPlayersAvailable && !enemyLeft)
      {
        //say you are awaiting the enemy's turn
        if (frame % 100 < 33)
        {
          fillText("Awaiting enemy turn..", WIDTH/2 - 100, buttonPosY, "18pt nature", "rgb(15, 15, 0)", "left", "middle");
        }
        else if (frame % 100 < 66)
        {
          fillText("Awaiting enemy turn...", WIDTH/2 - 100, buttonPosY, "18pt nature", "rgb(15, 15, 0)", "left", "middle");
        }
        else
        {
          fillText("Awaiting enemy turn....", WIDTH/2 - 100, buttonPosY, "18pt nature", "rgb(15, 15, 0)", "left", "middle");
        }
      }
      //show controls at top
      fillText("Use Attack: ENTER", 10, 10, "14pt nature", "rgb(25, 55, 5)", "left", "top");
      fillText("Confirm Enemy Selection: SHIFT", 10, 35, "14pt nature", "rgb(25, 55, 5)", "left", "top");
      fillText("Select Attack:", 9, 60, "14pt nature", "rgb(25, 55, 5)", "left", "top");
      ctx.drawImage(leftArrowImage, 115, 60, 20, 20);
      ctx.drawImage(rightArrowImage, 140, 60, 20, 20);
      
      //if you deal damage...
      if (showDealDamage && sendHittingAll)
      {
        //freezeFrame = frame;
        for (let i = 0; i < enemyTeam.length; i++)
        {
          alphValSend = drawBubbleDamage(sendDamageInfo.type, sendDamageInfo.number, i + 5, freezeFrameSend + 180, freezeFrameSend);
        }
      }
      else if (showDealDamage)
      {
        alphValSend = drawBubbleDamage(sendDamageInfo.type, sendDamageInfo.number, targetKnight, freezeFrameSend + 180, freezeFrameSend);
      }
      if (showTakeDamage && receiveHittingAll)
      {
        for (let i = 0; i < yourTeam.length; i++)
        {
          alphValReceive = drawBubbleDamage(receiveDamageInfo.type, receiveDamageInfo.number, i, freezeFrameReceive + 180, freezeFrameReceive);
        }
      }
      else if (showTakeDamage)
      {
        alphValReceive = drawBubbleDamage(receiveDamageInfo.type, receiveDamageInfo.number, targettedKnight, freezeFrameReceive + 180, freezeFrameReceive);
      }
      if (showHealSend)
      {
        alphValSend = drawBubbleDamage(sendDamageInfo.type, sendDamageInfo.number, 4 - targetKnight, freezeFrameSend + 180, freezeFrameSend);
      }
      if (showHealReceive)
      {
        alphValReceive = drawBubbleDamage(receiveDamageInfo.type, receiveDamageInfo.number, 9 - targettedKnight, freezeFrameReceive + 180, freezeFrameReceive);
      }
      if (alphValSend === 0)
      {
        showDealDamage = false;
        showHealSend = false;
      }
      if (alphValReceive === 0)
      {
        showTakeDamage = false;
        showHealReceive = false;
      }
      
      
      
      if (enemyLeft === true)
      {
        fillText("The enemy player", WIDTH/2, 75, "18pt nature", "rgb(15, 15, 0)", "center", "middle");
        fillText("has left the game!", WIDTH/2, 125, "18pt nature", "rgb(15, 15, 0)", "center", "middle");
      }
        
      directCurrKnight();
      
    };

    const setCalls = () => {

      //get your ticket number, room number, and send your team to the server
      //also sends utilities
      socket.on('getTicketNum', (data) => {
        yourTicketNum = data.ticket;
        yourRoomNum = data.room;
        console.log(`Your ticket num is: ${yourTicketNum}`);

        fillText(ctx, `You are in room: ${yourRoomNum}`, WIDTH*5/6, HEIGHT/12, "12px nature", "purple");

        socket.emit("sendTeam", {team: yourTeam, room: yourRoomNum, ticket: yourTicketNum});

        socket.emit("awaitBothPlayers", { ticket: yourTicketNum, room: yourRoomNum, ready: bothPlayersAvailable });
      });

      //once both players have arrived, start
      socket.on("stopWaiting", () => {
        bothPlayersAvailable = true;
        socket.emit("grabTeams", { ticket: yourTicketNum, team: yourTeam, room: yourRoomNum});
      });

      //receive the enemy team from the server
      socket.on("sendEnemyTeam", (data) => {
        //data.theBadGuys.image.src = 
        
        enemyTeam = data.theBadGuys;

        //once the enemy team is received, set gameplay order

        //find out the order of play
        let allCharactersBasedOnSpeed = [];

        for (let i = 0; i < yourTeam.length; i++)
        {
          allCharactersBasedOnSpeed[i] = yourTeam[i];
          allCharactersBasedOnSpeed[i].team = "me";
        }
        for (let i = yourTeam.length; i < yourTeam.length + enemyTeam.length; i++)
        {
          allCharactersBasedOnSpeed[i] = enemyTeam[i - yourTeam.length];
          allCharactersBasedOnSpeed[i].team = "them";
        }

        //order the characters
        allCharactersBasedOnSpeed.sort((a, b) => {
          return a.speed - b.speed;
        });
        allCharactersBasedOnSpeed.reverse();

        
        //doctor the ownership of one player so that it's the opposite
        if (yourTicketNum % 2 == 0)
        {
          allCharactersBasedOnSpeed = doctorOwnership(allCharactersBasedOnSpeed);
        }
        

        //save the turn order
        turnOrder = allCharactersBasedOnSpeed;

        socket.emit("firstTurn", {turnOrder, yourRoomNum});
      });

      socket.on("nextTurn", (data) => {
        
        turnOrder = data.newTurnOrder;
        if (turnOrder[0].team === "me")
        {
          takingTurn = true;
          turnTaken = false;
          stopBlinking = false;
        }
        currKnight = data.next;
      });
      
      socket.on("nextTurnEnemy", (data) => {
        
        
        turnOrder = doctorOwnership(data.newTurnOrder);
        if (turnOrder[0].team === "me")
        {
          takingTurn = true;
          turnTaken = false;
          stopBlinking = false;
        }
        currKnight = data.next;
      });
      
      socket.on("displayEnemyLeft", () => {
        enemyLeft = true;
      });
      
      socket.on("receiveDamageUI", (data) => {
        
        showTakeDamage = true;
        showDealDamage = false;
        if (data.targetType === "attackAll")
        {
          receiveHittingAll = true;
        }
        sendHittingAll = false;
        receiveDamageInfo.type = data.damType;
        receiveDamageInfo.number = data.damNum;
        if (data.damNum !== 0 && data.damNum !=="Miss!")
        {
          yourTeam[data.targetNum].shaking = true;
          for (let i = 0; i < enemyTeam.length; i++)
          {
            enemyTeam[i].shaking = false;
          }
        }
        
        targettedKnight = 4 - data.targetNum;
        freezeFrameReceive = frame;
      });
      
      socket.on("sendTeamsForNewTurn", (data) => {
        for (let i = 0; i < yourTeam.length; i++)
        {
          yourTeam[i].HLTH = data.myNewTeam[i].HLTH;
          yourTeam[i].DEF = data.myNewTeam[i].DEF;
          yourTeam[i].knockedOver = data.myNewTeam[i].knockedOver;
          yourTeam[i].poisoned = data.myNewTeam[i].poisoned;
          yourTeam[i].burned = data.myNewTeam[i].burned;
          yourTeam[i].spiked = data.myNewTeam[i].spiked;
          yourTeam[i].flying = data.myNewTeam[i].flying;
          yourTeam[i].alive = data.myNewTeam[i].alive;
        }
        
        for (let i = 0; i < enemyTeam.length; i++)
        {
          enemyTeam[i].HLTH = data.theirNewTeam[i].HLTH;
          enemyTeam[i].DEF = data.theirNewTeam[i].DEF;
          enemyTeam[i].knockedOver = data.theirNewTeam[i].knockedOver;
          enemyTeam[i].poisoned = data.theirNewTeam[i].poisoned;
          enemyTeam[i].burned = data.theirNewTeam[i].burned;
          enemyTeam[i].spiked = data.theirNewTeam[i].spiked;
          enemyTeam[i].flying = data.theirNewTeam[i].flying;
          enemyTeam[i].alive = data.theirNewTeam[i].alive;
        }
      });
      
      socket.on("receiveAbilityUI", (data) => {
        //showReceiveAssistBox = true;
        showHealReceive = true;
        showHealSend = false;
        receiveDamageInfo.type = data.abilityType;
        receiveDamageInfo.number = data.abilityNum;
        youTeam[i].shaking = false;
        for (let i = 0; i < enemyTeam.length; i++)
        {
          enemyTeam[i].shaking = false;
        }
        targettedKnight = 4 - data.targetNum;
        freezeFrameReceive = frame;
      });

    };

    const doctorOwnership = (fullTurnOrder) => {
      //doctor who owns what character
      for (let i = 0; i < yourTeam.length + enemyTeam.length; i++)
      {
        if (fullTurnOrder[i].team === "me")
        {
          fullTurnOrder[i].team = "them";
        }
        else if (fullTurnOrder[i].team === "them")
        {
          fullTurnOrder[i].team = "me";
        }
      }
      return fullTurnOrder;
    };

    const drawTint = (startX, startY, width, height, color) => {
      ctx.save();
      ctx.fillStyle = color;
      ctx.fillRect(startX, startY, width, height);
      ctx.restore();
    };
    
    const drawRectWithStroke = (xPos, yPos, width, height, fillStyle, strokeStyle, lineWidth) => {
      ctx.save();
      ctx.fillStyle = fillStyle;
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.fillRect(xPos, yPos, width, height);
      ctx.strokeRect(xPos, yPos, width, height);
      ctx.restore();
    };

    const drawRectOnlyStroke = (xPos, yPos, width, height, strokeStyle, lineWidth) => {
      ctx.save();
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.strokeRect(xPos, yPos, width, height);
      ctx.restore();
    };

    const drawRect = (xPos, yPos, width, height, fillStyle) => {
      ctx.save();
      ctx.fillStyle = fillStyle;
      ctx.fillRect(xPos, yPos, width, height);
      ctx.stroke();
      ctx.restore();
    };

    const fillText = (string, x, y, css, color, textAlign, textBaseline) => {
      ctx.save();
      ctx.font = css;
      ctx.textAlign = textAlign;
      ctx.textBaseline = textBaseline;
      ctx.fillStyle = color;
      ctx.fillText(string, x, y);
      ctx.restore();
    };

    const genDirection = () => {
      let x = Math.floor((Math.random() * 10) - 5);
      let y = Math.floor((Math.random() * 10) - 5);
      return {xDir: x, yDir: y};
    }

    const getRandNum = (min, max) => {
      let value = Math.floor((Math.random() * (max-min+1)) + min);
      return value;
    }

    const handleMessage = (data) => {
      draws[data.time] = data.coords;
      draw(data);
    };

    const loadImages = () => {
      backgroundImage.src = '../media/naturesKnightsbg.png';
      
      arrowImage.src = '../media/arrow.png';
      arrowSpritesheetImage.src = '../media/arrowSpritesheet.png';
      leftArrowImage.src = '../media/arrowLeft.png';
      rightArrowImage.src = '../media/arrowRight.png';
      healthCircleImage.src = '../media/healthCircle.png';
      
      knightImages.sponge.src = '../media/sponge.png';
      knightImages.seaSerpent.src = '../media/sea_serpent.png';
      knightImages.blossomBird.src = '../media/blossom_bird.png';
      knightImages.monkey.src = '../media/monkey.png';
      knightImages.stupidSnake.src = '../media/stupidSnake.png';
      knightImages.redRect.src = '../media/redRect.png';
      knightImages.savageTiger.src = '../media/savage_tiger_taken.png';
      knightImages.chipmonk.src = '../media/chipmonk.png';
      
      /*
      spongeImage.src = '../media/sponge.png';
      seaSerpentImage.src = '../media/sea_serpent.png';
      blossomBirdImage.src = '../media/blossom_bird.png';
      monkeyImage.src = '../media/monkey.png';
      stupidSnakeImage.src = '../media/stupid_snake.png';
      redRectImage.src = '../media/redRect.png';
      */
    };

    const loadScreenUI = () => {
      toggleMusicButton.onclick = toggleMusic;
    };

    const toggleMusic = (e) => {
      let myh5 = document.querySelector("h5");
      if (myh5.innerHTML == "On")
      {
        myh5.innerHTML = "Off";
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
      }
      else
      {
        myh5.innerHTML = "On";
        backgroundMusic.play();
      }
    };

    const loadAudio = () => {
      backgroundMusic.src = '../media/naturesKnights.wav';
      backgroundMusic.loop = true;
    };

    const init = () => {
      socket = io.connect();
      canvas.width = 750;
      canvas.height = 500;
      WIDTH = canvas.width;
      HEIGHT = canvas.height;
      buffer.width = WIDTH;
      buffer.height = HEIGHT;
      calculateTeam(5);
      setInputDaemon();
      loadImages();
      loadAudio();
      loadScreenUI();
      //backgroundMusic.play();
      //ghostImg.src = '../media/ghost.png';
      setCalls();
      //startFight();
      update();
    }

    function update()
    {
      draw(yourTeam, enemyTeam);
      checkPlayerInput();
      for (let i = 0; i < yourTeam.length; i++)
      {
        if (yourTeam[i].HLTH <= 0)
        {
          yourTeam[i].HLTH = 0;
          yourTeam[i].alive = false;
        }
        
      }
      for (let i = 0; i < enemyTeam.length; i++)
      {
        if (enemyTeam[i].HLTH <= 0)
        {
          enemyTeam[i].HLTH = 0;
          enemyTeam[i].alive = false;
        }
      }
      
      
      window.requestAnimationFrame(update);
    }

    window.onload = init;

  </script>
  <!--<script src="js/keys.js"></script>-->
</head>
<body>
  <h1>Nature's Knights</h1>
  <canvas>
  </canvas>
  
  <div id="credits">
    <div id="game_design">
      <h2>Game Design:<h3>Mark Obeldobel</h3></h2>
    </div>
    <div id="sound_design">
      <h2>Sound Design:<h3>Mark Obeldobel</h3></h2>
    </div>
    <div id="asset_production">
      <h2>Asset Production: <h3>Mark Obeldobel</h3></h2>
    </div>
  </div>
  
  <div id="musicToggle">
    <h4>Music</h4>
    <h5>Off</h5>
    <h6>Blah</h6>
  </div>
  <!--
  <section id="audioControls">
    <audio src="media/naturesKnights.wav" autostart="true" loop="true" hidden="true">
  </section>
  -->
  
</body>
</html>